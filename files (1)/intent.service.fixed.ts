import axios from "axios";
import { IntentAction, IntentResult, LLMResponse } from "./intent.types.js";
import { cleanAndParseJSON } from "./ai.service.js";
import { getBrainContext } from "./intent.context.service.js";

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INTENT SERVICE - Fixed with RESEARCH_BRAIN & Proper Email Body
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ Types â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export interface ChatMessage {
  role: 'user' | 'assistant' | 'system';
  content: string;
}

export interface ClassifyIntentParams {
  userText: string;
  userId: string;
  chatHistory?: ChatMessage[];
}

// â”€â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const LLM_API_URL = process.env.LLM_API_URL ?? "http://localhost:1234/v1/chat/completions";
const LLM_MODEL = process.env.LLM_MODEL ?? "local-model";
const LLM_TIMEOUT = Number(process.env.LLM_TIMEOUT ?? 30_000);

// â”€â”€â”€ System Prompt with RESEARCH_BRAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function buildJarvisSystemPrompt(
  brainContext: string,
  chatHistory?: ChatMessage[]
): string {
  // Historia rozmowy
  let historySection = '';
  if (chatHistory && chatHistory.length > 0) {
    historySection = '\n<CHAT_HISTORY>\n';
    const recentHistory = chatHistory.slice(-5);
    recentHistory.forEach(msg => {
      const role = msg.role === 'user' ? 'User' : 'Jarvis';
      historySection += `${role}: ${msg.content}\n`;
    });
    historySection += '</CHAT_HISTORY>\n';
  }

  return `You are JARVIS - AI assistant. Style: konkretny, pragmatyczny, pomocny. Zwrot: "mordo".

CURRENT DATE: ${new Date().toISOString()}

${historySection}

<BRAIN_CONTEXT>
${brainContext}
</BRAIN_CONTEXT>

CRITICAL: Respond ONLY with valid JSON - NO markdown, NO backticks, NO extra text.

JSON Format:
{
  "action": "SAVE_ONLY" | "SAVE_SEARCH" | "RESEARCH_BRAIN" | "SAVE_MAIL" | "CREATE_EVENT",
  "reasoning": "short technical explanation",
  "answer": "natural Polish response with 'mordo' style",
  "eventData": {...}  // ONLY if CREATE_EVENT
  "emailData": {      // ONLY if SAVE_MAIL
    "recipient": "email@example.com",
    "subject": "Subject line",
    "body": "Full email content generated by you"
  }
}

CLASSIFICATION RULES:

1. CREATE_EVENT â†’ date/time or reminder mentioned
   Extract: title, startDate (ISO 8601), category
   
2. SAVE_MAIL â†’ email sending request
   IMPORTANT: Generate FULL email body in "emailData.body"
   Extract recipient if found, suggest subject
   
3. RESEARCH_BRAIN â†’ user asks about information that:
   - Is NOT in current <BRAIN_CONTEXT>
   - Relates to user's own data/memories/notes
   - Example: "Co mi mÃ³wiÅ‚eÅ› o projekcie X?" when project X not in context
   Answer: "Zaraz sprawdzÄ™ w pamiÄ™ci, mordo. ChwilÄ™..."
   
4. SAVE_SEARCH â†’ user needs CURRENT info from internet:
   - News, prices, weather, latest updates
   - Example: "Jaka jest pogoda?" or "Co nowego w AI?"
   Answer: "Sprawdzam w internecie, mordo. Chwila."

5. SAVE_ONLY â†’ general conversation, greetings, simple questions
   Answer based on available context

AGENTIC LOGIC:
- If user asks about something and <BRAIN_CONTEXT> is empty â†’ use RESEARCH_BRAIN
- If user asks about current events/news â†’ use SAVE_SEARCH
- If user asks about their past notes/memories â†’ use RESEARCH_BRAIN
- DON'T say "nie wiem" - use appropriate research action instead!

FEW-SHOT EXAMPLES:

Example 1 - Greeting:
User: "Jak siÄ™ masz?"
{
  "action": "SAVE_ONLY",
  "reasoning": "Greeting, no action needed",
  "answer": "Wszystko git, mordo. Gotowy do roboty."
}

Example 2 - Reminder:
User: "Przypomnij mi jutro o 10 o spotkaniu"
{
  "action": "CREATE_EVENT",
  "reasoning": "Reminder with time",
  "answer": "Jasne, mordo. Ustawiam na jutro o 10:00.",
  "eventData": {
    "title": "Spotkanie",
    "startDate": "2024-12-26T10:00:00Z",
    "category": "reminder"
  }
}

Example 3 - Email with BODY:
User: "WyÅ›lij mail do john@example.com Å¼e projekt jest opÃ³Åºniony"
{
  "action": "SAVE_MAIL",
  "reasoning": "Email request with recipient and context",
  "answer": "Okej, mordo. WysyÅ‚am do john@example.com.",
  "emailData": {
    "recipient": "john@example.com",
    "subject": "Aktualizacja statusu projektu",
    "body": "CzeÅ›Ä‡,\\n\\nChciaÅ‚em poinformowaÄ‡, Å¼e projekt jest obecnie opÃ³Åºniony. PracujÄ™ nad rozwiÄ…zaniem problemu i wrÃ³cÄ™ z aktualizacjÄ… wkrÃ³tce.\\n\\nPozdrawiam"
  }
}

Example 4 - Internet Search:
User: "Jaka jest pogoda w Warszawie?"
{
  "action": "SAVE_SEARCH",
  "reasoning": "Current info needed from internet",
  "answer": "Sprawdzam pogodÄ™ w internecie, mordo. Chwila."
}

Example 5 - Brain Research (empty context):
User: "Co mi mÃ³wiÅ‚eÅ› o projekcie AI na uczelni?"
Brain Context: ğŸ’­ Brak relevantnych wspomnieÅ„
{
  "action": "RESEARCH_BRAIN",
  "reasoning": "User asks about past info, not in current context",
  "answer": "Zaraz sprawdzÄ™ w pamiÄ™ci, mordo. ChwilÄ™..."
}

Example 6 - Brain Research (incomplete context):
User: "Podaj mi szczegÃ³Å‚y tego projektu"
Brain Context: ğŸ“š Wspomnienia: [tylko tytuÅ‚ projektu]
{
  "action": "RESEARCH_BRAIN",
  "reasoning": "Context incomplete, need deeper search",
  "answer": "Mam tylko podstawowe info. ZagÅ‚Ä™biÄ™ siÄ™, mordo."
}

JARVIS STYLE:
- Be proactive: use research actions when needed
- "mordo" instead of "sir"
- Concise (2-3 sentences)
- Don't apologize for lack of knowledge - take action!

DATE PARSING:
- "jutro o 10" â†’ tomorrow 10:00
- "w piÄ…tek" â†’ next Friday 09:00
- "za tydzieÅ„" â†’ +7 days

REMEMBER: 
- ONLY valid JSON
- NO markdown, NO backticks
- Generate FULL email body in emailData.body
- Use RESEARCH_BRAIN when context is incomplete
- Use SAVE_SEARCH for current internet info`;
}

// â”€â”€â”€ Keyword Fallback â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const SEARCH_KEYWORDS = [
  /pogoda/i, /cena/i, /aktualn/i, /najnowsz/i, /dzisiaj/i, /teraz/i,
  /weather/i, /price/i, /current/i, /latest/i, /today/i, /now/i,
];

const RESEARCH_KEYWORDS = [
  /co (mi |)mÃ³wiÅ‚/i, /pamiÄ™tasz/i, /przypomnij mi o/i, /znajdÅº w notatkach/i,
  /what did (I|you) say/i, /do you remember/i, /find in my notes/i,
];

const MAIL_KEYWORDS = [
  /wyÅ›lij (e-?mail|mail|wiadomoÅ›Ä‡)/i, /napisz (do|mail)/i,
  /send (an? )?(e-?mail|message)/i,
];

const EVENT_KEYWORDS = [
  /przypomnij/i, /przypomnienie/i, /spotkanie/i, /kalendarz/i,
  /jutro/i, /dziÅ›/i, /w piÄ…tek/i,
  /remind/i, /reminder/i, /meeting/i, /tomorrow/i,
];

function keywordFallback(text: string): IntentResult {
  // Research Brain ma wysoki priorytet
  if (RESEARCH_KEYWORDS.some((re) => re.test(text))) {
    return { 
      action: "RESEARCH_BRAIN", 
      reasoning: "Keyword match: memory/notes",
      answer: "Zaraz sprawdzÄ™ w pamiÄ™ci, mordo."
    };
  }

  if (EVENT_KEYWORDS.some((re) => re.test(text))) {
    return { 
      action: "CREATE_EVENT", 
      reasoning: "Keyword match: date/reminder",
      answer: "Jasne, mordo. Ustawiam przypomnienie.",
      eventData: {
        title: text.substring(0, 100),
        startDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
        category: 'reminder'
      }
    };
  }
  
  if (MAIL_KEYWORDS.some((re) => re.test(text))) {
    return { 
      action: "SAVE_MAIL", 
      reasoning: "Keyword match: send/mail",
      answer: "Okej, mordo. PrzygotowujÄ™ maila."
    };
  }
  
  if (SEARCH_KEYWORDS.some((re) => re.test(text))) {
    return { 
      action: "SAVE_SEARCH", 
      reasoning: "Keyword match: current/latest",
      answer: "Sprawdzam w internecie, mordo."
    };
  }
  
  return { 
    action: "SAVE_ONLY", 
    reasoning: "General conversation",
    answer: "Åap, mordo. Jestem jak coÅ›."
  };
}

// â”€â”€â”€ JSON Parser â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const VALID_ACTIONS = new Set<IntentAction>([
  "SAVE_ONLY", 
  "SAVE_SEARCH",
  "RESEARCH_BRAIN", // â† NOWE!
  "SAVE_MAIL", 
  "CREATE_EVENT"
]);

function parseIntentJSON(raw: string): IntentResult | null {
  const parsed = cleanAndParseJSON(raw);
  
  if (!parsed) {
    console.warn('[IntentService] cleanAndParseJSON returned null');
    return null;
  }

  try {
    const action = parsed["action"];
    const reasoning = typeof parsed["reasoning"] === "string" 
      ? parsed["reasoning"] 
      : "No reasoning provided";
    const answer = typeof parsed["answer"] === "string"
      ? parsed["answer"]
      : "Okej, mordo.";

    if (typeof action === "string" && VALID_ACTIONS.has(action as IntentAction)) {
      const result: IntentResult = { 
        action: action as IntentAction, 
        reasoning,
        answer
      };
      
      // Dodaj eventData jeÅ›li CREATE_EVENT
      if (action === "CREATE_EVENT" && parsed["eventData"]) {
        result.eventData = parsed["eventData"] as IntentResult["eventData"];
      }
      
      // Dodaj emailData jeÅ›li SAVE_MAIL (z body!)
      if (action === "SAVE_MAIL" && parsed["emailData"]) {
        result.emailData = parsed["emailData"] as IntentResult["emailData"];
      }
      
      return result;
    }
  } catch (err) {
    console.error("[IntentService] JSON parse failed:", err);
  }

  return null;
}

// â”€â”€â”€ Main Service â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

/**
 * Klasyfikuje intencjÄ™ z RESEARCH_BRAIN support
 */
export async function classifyIntent(params: ClassifyIntentParams): Promise<IntentResult> {
  const { userText, userId, chatHistory = [] } = params;
  
  console.log('[IntentService] â•â•â• Classifying intent â•â•â•');
  console.log('[IntentService] User:', userId);
  console.log('[IntentService] Text:', userText);

  try {
    // 1. Pobierz kontekst mÃ³zgu
    console.log('[IntentService] Fetching brain context...');
    const brainContext = await getBrainContext(userId, userText);
    console.log('[IntentService] Brain context retrieved:', brainContext.hasContext);

    // 2. Zbuduj System Prompt
    const systemPrompt = buildJarvisSystemPrompt(
      brainContext.synapticTree,
      chatHistory
    );

    // 3. WywoÅ‚aj LLM z temperature 0.1
    console.log('[IntentService] Calling LLM with temperature=0.1...');
    
    const response = await axios.post<LLMResponse>(
      LLM_API_URL,
      {
        model: LLM_MODEL,
        temperature: 0.1, // StabilnoÅ›Ä‡!
        max_tokens: 800,  // WiÄ™cej dla email body
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userText },
        ],
      },
      { timeout: LLM_TIMEOUT }
    );

    const rawContent = response.data?.choices?.[0]?.message?.content ?? "";
    console.log("[IntentService] LLM raw output length:", rawContent.length);

    // 4. Parsuj przez cleanAndParseJSON
    const llmResult = parseIntentJSON(rawContent);
    
    if (llmResult) {
      console.log("[IntentService] âœ“ Successfully parsed:", {
        action: llmResult.action,
        hasAnswer: !!llmResult.answer,
        hasEmailBody: !!(llmResult.emailData?.body)
      });
      return llmResult;
    }

    console.warn("[IntentService] âš ï¸ LLM output not parseable â†’ keyword fallback");
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    console.error(`[IntentService] âŒ Error: ${message}`);
  }

  // 5. Keyword fallback
  const kwResult = keywordFallback(userText);
  console.log("[IntentService] Keyword fallback result:", kwResult.action);
  return kwResult;
}

// â”€â”€â”€ Helper: Validate Event Data â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

export function validateEventData(eventData?: IntentResult["eventData"]): {
  isValid: boolean;
  normalized?: IntentResult["eventData"];
  error?: string;
} {
  if (!eventData) {
    return { isValid: false, error: "Missing eventData" };
  }

  if (!eventData.title || !eventData.startDate) {
    return { isValid: false, error: "Missing title or startDate" };
  }

  const startDate = new Date(eventData.startDate);
  if (isNaN(startDate.getTime())) {
    return { isValid: false, error: "Invalid startDate format" };
  }

  if (eventData.endDate) {
    const endDate = new Date(eventData.endDate);
    if (isNaN(endDate.getTime())) {
      return { isValid: false, error: "Invalid endDate format" };
    }
    
    if (endDate <= startDate) {
      return { isValid: false, error: "endDate must be after startDate" };
    }
  }

  return {
    isValid: true,
    normalized: {
      title: eventData.title.trim(),
      description: eventData.description?.trim() || undefined,
      startDate: startDate.toISOString(),
      endDate: eventData.endDate ? new Date(eventData.endDate).toISOString() : undefined,
      category: eventData.category || 'other',
    },
  };
}
